# 76. Minimum Window Substring
## 题目
>Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".  
The testcases will be generated such that the answer is unique.  
A substring is a contiguous sequence of characters within the string.  

两个字符串s和t，长度分别为m和n。返回所有t的字符都在s中的最小覆盖子串。  
如果没有，则返回为空。  
子串是一个连续的字符串。  
答案唯一

>Example 1:  
Input: s = "ADOBECODEBANC", t = "ABC"  
Output: "BANC"  
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.  

>Example 2:  
Input: s = "a", t = "a"  
Output: "a"  
Explanation: The entire string s is the minimum window.  

>Example 3:  
Input: s = "a", t = "aa"  
Output: ""  
Explanation: Both 'a's from t must be included in the window.  
Since the largest window of s only has one 'a', return empty string.

当有重复子串的时候，覆盖子串里面的数量必须比他大，否则为空。所以我们可以在最开始的时候增加一个判断，如果t的长度大于s的长度，则肯定返回值为空。    
 

>Constraints:  
m == s.length  
n == t.length  
1 <= m, n <= 105  
s and t consist of uppercase and lowercase English letters.

## 思考
一开始我想，循环遍历以下s，然后记录每个t字母最后出现的下标。  
但是还有重复，这个个数该怎么解决。。而且这样出来的只能是最后覆盖子串，没有最小这一说了。。  

或者滑动窗口，从最初出现第一个包含在t中的字符的位置开始，设置一个窗口的大小最小长度为n(t的长度)。然后判断是否包含所有的t，如果不是则将窗口增加一。判断是否含有所有的t字符直到含有一个字符为止。 但是还是不知道怎么解决重复的问题。
## 答案
### 1. 滑动窗口
现设置两个指针，left and right。初始的时候都是0. 先移动right指针，让窗口中包含所有的t中的字符。然后记录一下这个左右指针中间的字符串。  
接着移动left指针，每一次移动，判断窗口中的字符串是否还符合要求。如果不符合回退一格，符合则进一格并判断长度是否是最小的。

利用了一个两个计数器，一个计数器存储t中所需要的字符的个数，第二个计数器存储窗口中的字符的个数。  
再维护两个变量formed，required，用来表达已经完成匹配的字符的个数。只有相等的时候才会进行统计。所以超过了不统计，也符合题目要求。  
当required 和 formed相等的时候就说明满足条见了。
在满足条件的情况下对左右指针微调，然后匹配周围是否还有满足条件的。
```python3
def minWindow(self, s, t):
    """
    :type s: str
    :type t: str
    :rtype: str
    """

    if not t or not s:
        return ""

    # Dictionary which keeps a count of all the unique characters in t.
    dict_t = Counter(t)

    # Number of unique characters in t, which need to be present in the desired window.
    required = len(dict_t)

    # left and right pointer
    l, r = 0, 0

    # formed is used to keep track of how many unique characters in t are present in the current window in its desired frequency.
    # e.g. if t is "AABC" then the window must have two A's, one B and one C. Thus formed would be = 3 when all these conditions are met.
    formed = 0

    # Dictionary which keeps a count of all the unique characters in the current window.
    window_counts = {}

    # ans tuple of the form (window length, left, right)
    ans = float("inf"), None, None

    while r < len(s):

        # Add one character from the right to the window
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1

        # If the frequency of the current character added equals to the desired count in t then increment the formed count by 1.
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1

        # Try and contract the window till the point where it ceases to be 'desirable'.
        while l <= r and formed == required:
            character = s[l]

            # Save the smallest window until now.
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)

            # The character at the position pointed by the `left` pointer is no longer a part of the window.
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1

            # Move the left pointer ahead, this would help to look for a new window.
            l += 1    

        # Keep expanding the window once we are done contracting.
        r += 1    
    return "" if ans[0] == float("inf") else s[ans[1] : ans[2] + 1]
```
### 2. 优化的滑动窗口
改动很小。

```python3
def minWindow(self, s, t):
    """
    :type s: str
    :type t: str
    :rtype: str
    """
    if not t or not s:
        return ""

    dict_t = Counter(t)

    required = len(dict_t)

    # Filter all the characters from s into a new list along with their index.
    # The filtering criteria is that the character should be present in t.
    filtered_s = []
    for i, char in enumerate(s):
        if char in dict_t:
            filtered_s.append((i, char))

    l, r = 0, 0
    formed = 0
    window_counts = {}

    ans = float("inf"), None, None

    # Look for the characters only in the filtered list instead of entire s. This helps to reduce our search.
    # Hence, we follow the sliding window approach on as small list.
    while r < len(filtered_s):
        character = filtered_s[r][1]
        window_counts[character] = window_counts.get(character, 0) + 1

        if window_counts[character] == dict_t[character]:
            formed += 1

        # If the current window has all the characters in desired frequencies i.e. t is present in the window
        while l <= r and formed == required:
            character = filtered_s[l][1]

            # Save the smallest window until now.
            end = filtered_s[r][0]
            start = filtered_s[l][0]
            if end - start + 1 < ans[0]:
                ans = (end - start + 1, start, end)

            window_counts[character] -= 1
            if window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1    

        r += 1    
    return "" if ans[0] == float("inf") else s[ans[1] : ans[2] + 1]
```
 
## 总结
[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)  
[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)